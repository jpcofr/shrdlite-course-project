///<reference path="Util.ts"/>
///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>
///<reference path="lib/collections.ts"/>

/*** Planner module. ***/

module Planner {

    /*** Public part. ***/

    // Top-level driver for the Planner. Calls `planInterpretation`
    // for each given interpretation generated by the Interpreter.
    // @param interpretations List of possible interpretations.
    // @param currentState The current state of the world.
    // @returns Augments Interpreter.InterpretationResult with
    //   a plan represented by a list of strings.
    export function plan (interpretations : Interpreter.InterpretationResult[],
                          currentState : WorldState                           )
    : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan != null && result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // Only throw the first error found.
            throw "Planning error: Could not find a plan to execute your command.";
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    /*** Private part. ***/

    // Returns a sequence of commands ("r" or "l") to move the arm between
    // the given columns.
    function makeCommands (sourceCol : number, destCol : number) : string[] {
        var result : string[] = [];
        var atomic = sourceCol < destCol ? "r" : "l";

        var distance = sourceCol - destCol;
        distance = distance < 0 ? -distance : distance;

        for (var i = 0; i < distance; i ++) {result.push(atomic);}

        return result;
    }

    // Edges are extended to contain useful information.
    class SearchEdge extends Edge<WorldState> {
        cmds : string[];
        objId : string;
        locId : string;
        isDropping: boolean;
    }

    // Generates a graph with WorldStates as nodes, with an edge from
    // one state to another if the latter is reachable from the former
    // by:
    // - Putting the object in the arm down in a free location
    //   (if the arm is holding an object).
    // - Picking up an object that is at the top of a stack
    //   (if the arm is empty).
    class SearchSpace implements Graph<WorldState> {
        outgoingEdges = function (state : WorldState) : SearchEdge[] {
            var result : SearchEdge[] = [];

            if (state.holding == null) { // The arm is empty.
                for (var sourceCol in state.stacks) {
                    if(state.stacks[sourceCol].length > 0) {
                        // The stack contains an object that can be picked up.
                        var sourceRow = state.stacks[sourceCol].length - 1;
                        var sourceLast = state.stacks[sourceCol][sourceRow];

                        var newState : WorldState = {
                            stacks: cloneMatrix(state.stacks),
                            holding: sourceLast,
                            arm: parseInt(sourceCol),
                            objects: state.objects,
                            examples: state.examples,
                            clarifying: false
                        }
                        newState.stacks[sourceCol].pop();

                        var commands : string[] = [];
                        commands = commands.concat(makeCommands(state.arm, parseInt(sourceCol)));
                        commands.push("p");

                        var originalPosition =
                            state.stacks[sourceCol][sourceRow - 1] != null ? state.stacks[sourceCol][sourceRow - 1] : "floor";
                        result.push( { from : state           ,
                                       to   : newState        ,
                                       cost : commands.length ,
                                       cmds : commands,
                                       objId : sourceLast,
                                       locId :  originalPosition,
                                       isDropping : false
                                   } );
                    }
                }
            }
            else { // The arm is holding an object.
                var heldObj = state.holding;
                for (var destCol in state.stacks) {
                    var destRow = state.stacks[destCol].length - 1;
                    var destLast = state.stacks[destCol][destRow];
                    if ( state.stacks[destCol].length == 0
                         || !againstPhysics("ontop", heldObj, destLast, state)
                         || !againstPhysics("inside", heldObj, destLast, state)
                       ) {
                        // The held object can legally be placed on top of the stack.
                        var newState : WorldState = {
                            stacks: cloneMatrix(state.stacks),
                            holding: null,
                            arm: parseInt(destCol),
                            objects: state.objects,
                            examples: state.examples,
                            clarifying: false
                        }
                        newState.stacks[destCol].push(state.holding);

                        var commands : string[] = [];
                        commands = commands.concat(makeCommands(state.arm, parseInt(destCol)));
                        commands.push("d");
                        var destinationPosition = destLast != null ? destLast : "floor";

                        result.push( { from : state           ,
                                       to   : newState        ,
                                       cost : commands.length ,
                                       cmds : commands,
                                       objId : heldObj,
                                       locId: destinationPosition,
                                       isDropping : true
                                    } );
                    }
                }
            }

            return result;
        }

        compareNodes = function (s1 : WorldState, s2 : WorldState) : number
        {return stringifyState(s1).localeCompare(stringifyState(s2));}
    }

     // Checks whether the given literal is satisfied in the given
     // world state.
    function isValid(lit : Interpreter.Literal, state : WorldState) : boolean {
        // Either the relation is "holding" with one argument, or there are 2 arguments.
        var isTrue : boolean = false;
        var ob1 : string = lit.args[0];
        if (lit.relation == "holding") {
            isTrue = (ob1 == state.holding);
        }
        else {
            // We have 2 arguments, an object and a location.
            var ob2 = lit.args[1];
            var loc1 = Interpreter.locateObjectId(ob1, state);
            var loc2 = Interpreter.locateObjectId(ob2, state);
            if (ob1 == "floor") {
                isTrue = lit.relation == "under";
            }
            else if (ob2 == "floor") {
                isTrue = lit.relation == "above";
                if (lit.relation == "ontop") {
                    isTrue = loc1.row == 0;
                }
            }
            else {
                // We are not dealing with the floor.
                switch(lit.relation) {
                case "ontop" :
                    // Objects are "inside" boxes but "ontop" of other objects.
                    isTrue = (loc1.col == loc2.col && loc1.row == loc2.row + 1 && state.objects[ob2].form != "box");
                    break;
                case "inside" :
                    isTrue = (loc1.col == loc2.col && loc1.row == loc2.row + 1 && state.objects[ob2].form == "box");
                    // Special case for nested boxes.
                    var inside = state.stacks[loc2.col][loc2.row+1];
                    if (inside != null && state.objects[inside].form == "box") {
                        isTrue = isTrue || (loc1.col == loc2.col && loc1.row == loc2.row + 2);
                    }
                    break;
                case "above" :
                    isTrue = (loc1.col == loc2.col && loc1.row > loc2.row);
                    break;
                case "under" :
                    isTrue = (loc1.col == loc2.col && loc1.row < loc2.row);
                    break;
                case "beside" :
                    isTrue = (Math.abs(loc1.col - loc2.col) == 1);
                    break;
                case "leftof" :
                    isTrue = (loc1.col < loc2.col);
                    break;
                case "rightof" :
                    isTrue = (loc1.col > loc2.col);
                    break;
                }
            }
        }
        return (lit.polarity == isTrue);
    }

    // Checks whether the given formula is satisfied in the given state.
    function isSatisfied(formula : Interpreter.DNFFormula, state : WorldState) : boolean {
        var result : boolean = false;
        for (let conjunction of formula) {
            result = true;
            for (let literal of conjunction) {
                if (!isValid(literal,state)) {
                    result = false;
                }
            }
            if (result) {
                // All the literals in the conjunction are true in the current state.
                return true;
            }
        }
        return false;
    }

    // A heuristic for the minimum number of steps needed for the robot arm to pick
    // pick up an object assuming it is already positioned above the correct column.
    function minAccess(obj: string, state: WorldState) : number {
        if (obj == "floor" || obj == state.holding) {
            return 0;
        }
        else {
            var loc = Interpreter.locateObjectId(obj,state);
            var height = state.stacks[loc.col].length; // Height of the stack.
            var above = height - loc.row - 1; // Number of objects above obj.
            // For each object above obj we need at least 4 moves to get that
            // object out of our way (pick it up, move it at least 1 stack,
            //release it, move back into position).
            return above*4;
        }
    }

    // A heuristic for how far a given state is from a goal literal.
    // Assumes that the cost is the length of a path (# of l,r,p, or d commands).
    function litHeuristic(state: WorldState, lit: Interpreter.Literal) : number {
        if (isValid(lit,state)) {
            return 0;
        }
        else {
            // The goal has not been reached.
            var minSteps = 0;
            var ob1 : string = lit.args[0];
            var loc1 = Interpreter.locateObjectId(ob1, state);
            var armPos : number = state.arm;
            if (lit.relation == "holding") {
                minSteps = Math.abs(loc1.col - armPos) + 1;
            }
            else {
                // We have 2 arguments.
                var ob2 = lit.args[1];
                var loc2 = Interpreter.locateObjectId(ob2, state);
                var access1 = minAccess(ob1,state);
                if (ob2 == "floor") {
                    if (ob1 == state.holding) {
                        // At best, we just need to put the object down.
                        minSteps = 1;
                    }
                    else {
                        // We need to access the object, pick it up,
                        // move it at least 1 column, and put it down.
                        minSteps = access1 + 3;
                    }
                }
                else {
                    // We are not dealing with the floor.

                    // Minimum number of arm moves to the position of the object to be moved.
                    var minArm = Math.min(Math.abs(armPos - loc1.col), Math.abs(armPos - loc2.col));
                    var access2 = minAccess(ob2,state);
                    switch(lit.relation) {
                    case "ontop" :
                    case "above" :
                    case "under" :
                        // Minimum number of moves from original object position to new one.
                        var minMove = Math.abs(loc1.col - loc2.col);
                        break;
                    case "inside" :
                        var minMove = Math.abs(loc1.col - loc2.col);
                        // Nested box exception, less moves are needed to access a box if
                        // it's sufficient to place the object in another box inside the box.
                        var inside = state.stacks[loc2.col][loc2.row + 1];
                        if (inside != null && state.objects[inside].form == "box" && state.objects[ob1].size == "small") {
                            access2 = access2 - 4;
                        }
                        break;
                    case "beside" :
                        var minMove = Math.abs(loc1.col - loc2.col) - 1;
                        break;
                    case "leftof" :
                    case "rightof" :
                        // Since the literal is not true we know that if the goal
                        // is leftof(a,b) a must currently be to the right of b
                        // (or in the same column), and vice versa.
                        var minMove = Math.abs(loc1.col - loc2.col) + 1;
                        break;
                    }
                    // We add 1 step for dropping the object into position.
                    minSteps = minArm + access1 + access2 + minMove + 1;
                }
            }
        }
        return minSteps;
    }

    // A heuristic for how far a given state is from a goal DNF formula.
    // based on the cost being the length of a path (# of l,r,p and d commands).
    function heuristic(state : WorldState, goal : Interpreter.DNFFormula) : number {
        var min = Number.MAX_VALUE;
        for (let conjunction of goal) {
            var lHs = conjunction.map(function (x) { return litHeuristic(state,x);})
            var maxH = Math.max(...lHs);
            if (maxH < min) {
                min = maxH;
            }
        }
        return min;
    }

    /**
     * The core planner function.
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
        var plan : string[] = [];
        var graph = new SearchSpace();
        var startNode = state;
        var goal = interpretation;
        var isGoal = (s: WorldState) => isSatisfied(goal,s);
        var h = (s: WorldState) => heuristic(s,goal);
        var toStr = (s: WorldState) => stringifyState(s);
        var objNamesMap = objectDescriptions(state);
        try {
            var result = <SearchEdge[]> aStarSearch(graph, startNode, isGoal, h, 10, toStr);

            var lastEdge = new SearchEdge();
            var isHolding = false;
            var isFirstEdge = true;
            for (let edge of result) {
                // Generate an utterance describing what the robot is doing.
                var stepDesc = "";
                var locDesc = edge.locId == "floor" ? "the floor" : objNamesMap.getValue(edge.locId);
                if (isFirstEdge) {
                    isFirstEdge = false;
                    if (edge.isDropping){
                        // If the robot starts with an object in the arm we describe putting the,
                        // object down, otherwise "dropping" is combined with the previous "taking"
                        // into a "moving" utterance.
                        stepDesc+= "Dropping "+ objNamesMap.getValue(edge.objId);
                        stepDesc+= " on " + locDesc + ".";
                    }
                } else if (edge.isDropping){
                    var originDesc = lastEdge.locId == "floor" ? "the floor" : objNamesMap.getValue(lastEdge.locId);
                    stepDesc+= "Moving "+ objNamesMap.getValue(edge.objId);
                    stepDesc+= " from "+ originDesc;
                    stepDesc+= " to "+ locDesc + ".";
                } else if(result.indexOf(edge) == result.length-1){
                    // The robot ends by picking up an object (and never puts it down).
                    stepDesc+= "Taking "+ objNamesMap.getValue(edge.objId);
                    stepDesc+= " from "+ locDesc + ".";
                }

                plan.push(stepDesc);
                plan = plan.concat(edge.cmds);
                lastEdge = edge;
            }
        }
        catch (e) {
            console.log("Planner failure!");
            plan = null;
        }
        return plan;
    }

}
